webpackHotUpdate(3, {
  /***/ 99: /***/ function(module, exports, __webpack_require__) {
    'use strict'
    eval(
      "\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _types = __webpack_require__(2);\n\nvar _utils = __webpack_require__(1);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar History = function () {\n  function History(opts) {\n    var _this = this;\n\n    _classCallCheck(this, History);\n\n    var index = opts.index,\n        entries = opts.entries,\n        saveHistory = opts.saveHistory,\n        basenames = opts.basenames;\n\n\n    this.saveHistory = saveHistory || function () {};\n\n    this.basename = entries[index].basename;\n    this.basenames = basenames;\n\n    this.entries = [];\n    this.index = -1;\n    this.length = 0;\n    this.location = null;\n\n    var nextState = {\n      kind: 'load',\n      entries: entries,\n      index: index,\n      location: entries[index]\n    };\n\n    var nextHistory = this._createNextHistory(nextState);\n\n    var commit = function commit() {\n      _this._updateHistory(nextState);\n    };\n\n    this.firstRoute = { nextHistory: nextHistory, commit: commit, type: _types.UPDATE_HISTORY };\n  }\n\n  // API:\n\n  _createClass(History, [{\n    key: 'push',\n    value: function push(path) {\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var _this2 = this;\n\n      var basename = arguments[2];\n      var notify = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n      var foundBasename = (0, _utils.findBasename)(path, this.basenames);\n      if (foundBasename) path = path.substr(foundBasename.length);\n\n      basename = foundBasename || basename;\n      if (typeof basename === 'string') this.setBasename(basename);\n\n      var key = (0, _utils.createKey)();\n      var bn = this.basename;\n      var location = (0, _utils.createLocation)(path, state, key, this.location, bn);\n      var back = this._isBack(location); // automatically determine if the user is just going back or next to a URL already visited\n      var next = this._isNext(location);\n      var kind = back ? 'back' : next ? 'next' : 'push';\n\n      if (/back|next/.test(kind)) {\n        return this.jump(back ? -1 : 1, state, undefined, undefined, notify);\n      }\n\n      var index = back ? this.index - 1 : this.index + 1;\n      var entries = this._pushToFront(location, this.entries, index, kind);\n      var nextState = { kind: kind, location: location, index: index, entries: entries };\n      var nextHistory = this._createNextHistory(nextState);\n      var commit = function commit() {\n        return _this2._push(nextState);\n      };\n\n      return this._notify({ nextHistory: nextHistory, commit: commit }, notify);\n    }\n  }, {\n    key: 'replace',\n    value: function replace(path) {\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var _this3 = this;\n\n      var basename = arguments[2];\n      var notify = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n      var foundBasename = (0, _utils.findBasename)(path, this.basenames);\n      if (foundBasename) path = path.substr(foundBasename.length);\n\n      basename = foundBasename || basename;\n      if (typeof basename === 'string') this.setBasename(basename);\n\n      var k = (0, _utils.createKey)();\n      var bn = this.basename;\n      var location = (0, _utils.createLocation)(path, state, k, this.location, bn);\n      var back = this._isBack(location); // automatically determine if the user is just going back or next to a URL already visited\n      var next = this._isNext(location);\n      var kind = back ? 'back' : next ? 'next' : 'redirect';\n\n      if (/back|next/.test(kind)) {\n        return this.jump(back ? -1 : 1, state, undefined, undefined, notify);\n      }\n\n      var index = this.index;\n      var entries = this.entries.slice(0);\n\n      entries[index] = location;\n\n      var nextState = { kind: kind, location: location, entries: entries, index: index };\n      var nextHistory = this._createNextHistory(nextState);\n      var commit = function commit() {\n        return _this3._replace(nextState);\n      };\n\n      return this._notify({ nextHistory: nextHistory, commit: commit }, notify);\n    }\n  }, {\n    key: 'replacePop',\n    value: function replacePop(path) {\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var basename = arguments[2];\n\n      var _this4 = this;\n\n      var notify = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      var pop = arguments[4];\n\n      var foundBasename = (0, _utils.findBasename)(path, this.basenames);\n      if (foundBasename) path = path.substr(foundBasename.length);\n\n      basename = foundBasename || basename;\n      if (typeof basename === 'string') this.setBasename(basename);\n\n      var k = (0, _utils.createKey)();\n      var bn = this.basename;\n      var location = (0, _utils.createLocation)(path, state, k, this.location, bn);\n      var index = pop.index;\n      var entries = pop.entries.slice(0);\n      var kind = index < this.index ? 'back' : 'next';\n\n      entries[index] = location;\n\n      var nextState = { kind: kind, location: location, entries: entries, index: index };\n      var nextHistory = this._createNextHistory(nextState);\n      var commit = function commit() {\n        return _this4._replace(nextState, pop.location, pop.n);\n      };\n\n      return this._notify({ nextHistory: nextHistory, commit: commit }, notify);\n    }\n  }, {\n    key: 'jump',\n    value: function jump(n, state) {\n      var byIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var kind = arguments[3];\n\n      var _this5 = this;\n\n      var notify = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n      var revertPop = arguments[5];\n\n      console.log('N', n);\n      n = this._resolveN(n, byIndex);\n      kind = kind || (n < 0 ? 'back' : 'next');\n\n      var isPop = !!revertPop;\n      var index = this.index + n;\n      var entries = this.entries.slice(0);\n      var location = entries[index] = _extends({}, this.entries[index]);\n      var nextState = { kind: kind, location: location, index: index, entries: entries };\n      var nextHistory = this._createNextHistory(nextState);\n      var commit = function commit() {\n        return _this5._jump(nextState, n, isPop);\n      };\n      var info = n === -1 || n === 1 ? null : 'jump'; // info === jump will tell middleware/transformAction.js to create custom `prev`\n\n      state = typeof state === 'function' ? state(location.state) : state;\n      location.state = _extends({}, location.state, state);\n\n      if (!this.entries[index]) {\n        throw new Error('[rudy] no entry at index: ' + index + '. Consider using `history.canJump(n)`.');\n      }\n\n      return this._notify({ nextHistory: nextHistory, commit: commit, info: info, revertPop: revertPop }, notify);\n    }\n  }, {\n    key: 'setState',\n    value: function setState(state, n) {\n      var _this6 = this;\n\n      var byIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var notify = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n      n = this._resolveN(n, byIndex);\n\n      var curIndex = this.index;\n      var index = this.index + n;\n      var entries = this.entries.slice(0);\n      var changedLocation = entries[index] = _extends({}, this.entries[index]);\n      var location = n === 0 ? changedLocation : this.location; // insure if state set on current entry, location is not stale\n      var nextState = { kind: 'setState', location: location, index: curIndex, entries: entries };\n      var nextHistory = this._createNextHistory(nextState);\n      var commit = function commit() {\n        return _this6._setState(nextState, n);\n      };\n\n      state = typeof state === 'function' ? state(changedLocation.state) : state;\n      changedLocation.state = _extends({}, changedLocation.state, state);\n\n      if (!this.entries[index]) {\n        throw new Error('[rudy] no entry at index: ' + index + '. Consider using `history.canJump(n)`.');\n      }\n\n      return this._notify({ nextHistory: nextHistory, commit: commit }, notify);\n    }\n  }, {\n    key: 'back',\n    value: function back(state) {\n      var notify = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      return this.jump(-1, state, false, 'back', notify);\n    }\n  }, {\n    key: 'next',\n    value: function next(state) {\n      var notify = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      return this.jump(1, state, false, 'next', notify);\n    }\n  }, {\n    key: 'reset',\n    value: function reset(entries, index, kind) {\n      var _this7 = this;\n\n      var notify = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n      entries = entries.map(function (e) {\n        return (0, _utils.createLocation)(e);\n      });\n      index = index !== undefined ? index : entries.length - 1;\n\n      if (!kind) {\n        if (entries.length > 1) {\n          if (index === entries.length - 1) kind = 'next'; // assume the user would be going forward in the new entries stack, i.e. if at head\n          else if (index === this.index) kind = 'redirect';else kind = index < this.index ? 'back' : 'next'; // assume the user is going 'back' if lower than current index, and 'next' otherwise\n        } else kind = 'load'; // if one entry, set kind to 'load' so app can behave as if it's loaded for the first time\n      }\n\n      if (!entries[index]) {\n        throw new Error('[rudy] no location entry at index: ' + index + '.');\n      }\n\n      var location = _extends({}, entries[index]);\n      var nextState = { kind: kind, location: location, index: index, entries: entries };\n      var nextHistory = this._createNextHistory(nextState);\n      var commit = function commit() {\n        return _this7._reset(nextState);\n      };\n\n      return this._notify({ nextHistory: nextHistory, commit: commit, info: 'reset' }, notify);\n    }\n  }, {\n    key: 'canJump',\n    value: function canJump(n, byIndex) {\n      n = this._resolveN(n, byIndex);\n      return !!this.entries[this.index + n];\n    }\n  }, {\n    key: 'listen',\n    value: function listen(fn) {\n      var _this8 = this;\n\n      this._listener = fn;\n      return function () {\n        return _this8._listener = null;\n      };\n    }\n  }, {\n    key: 'setBasename',\n    value: function setBasename(basename) {\n      this.basename = (0, _utils.formatSlashes)(basename);\n    }\n\n    // UTILS:\n\n  }, {\n    key: '_notify',\n    value: function _notify(action) {\n      var notify = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      action.type = _types.UPDATE_HISTORY;\n      action.commit = this._once(action.commit);\n      if (notify && this._listener) return this._listener(action);\n      return action;\n    }\n  }, {\n    key: '_once',\n    value: function _once(commit) {\n      var committed = false;\n\n      return function () {\n        if (committed) return;\n        committed = true;\n        return commit.apply(undefined, arguments);\n      };\n    }\n  }, {\n    key: '_createHref',\n    value: function _createHref(location) {\n      return location.basename + (0, _utils.createPath)(location);\n    }\n  }, {\n    key: '_isBack',\n    value: function _isBack(location) {\n      var entry = this.entries[this.index - 1];\n      return entry && entry.url === location.url;\n    }\n  }, {\n    key: '_isNext',\n    value: function _isNext(location) {\n      var entry = this.entries[this.index + 1];\n      return entry && entry.url === location.url;\n    }\n  }, {\n    key: '_isAfter',\n    value: function _isAfter(location) {\n      return this.entries.slice(this.index + 1).find(function (e) {\n        return e.url === location.url;\n      });\n    }\n  }, {\n    key: '_updateHistory',\n    value: function _updateHistory(state) {\n      Object.assign(this, state);\n      this.length = state.entries ? state.entries.length : this.length;\n      this.saveHistory(this);\n    }\n  }, {\n    key: '_createNextHistory',\n    value: function _createNextHistory(state) {\n      var next = Object.assign({ type: _types.UPDATE_HISTORY }, this, state);\n      next.length = state.entries ? state.entries.length : this.length;\n      return next;\n    }\n  }, {\n    key: '_pushToFront',\n    value: function _pushToFront(location, prevEntries, index) {\n      var entries = prevEntries.slice(0);\n      var isBehindHead = entries.length > index;\n\n      if (isBehindHead) {\n        var entriesToDelete = entries.length - index;\n        entries.splice(index, entriesToDelete, location);\n      } else {\n        entries.push(location);\n      }\n\n      return entries;\n    }\n  }, {\n    key: '_resolveN',\n    value: function _resolveN(n, byIndex) {\n      if (typeof n === 'string') {\n        var index = this.entries.findIndex(function (e) {\n          return e.key === n;\n        });\n        return index - this.index;\n      }\n\n      if (byIndex) {\n        return n - this.index;\n      }\n\n      return n || 0;\n    }\n  }]);\n\n  return History;\n}();\n\n// setStateOld(state, n, byIndex, notify = true) {\n//   if (!n && !byIndex) {\n//     return this.jump(0, state, false, 'setState', notify)                       // setState on current entry (primary use-case)\n//   }\n\n//   const i = this.index                                                          // current index, which is where we'll return to after setting the state on a different entry\n//   const { nextHistory: nh } = this.jump(n, state, byIndex, 'setState', false)   // jump to different entry and set state on it\n//   const nextHistory = { ...nh, index: i, location: this.entries[i] }\n//   const { kind, location, index, entries } = nextHistory\n//   const nextState = { kind, location, index, entries }\n//   const resolvedN = this._resolveN(n, byIndex)\n//   const commit = () => this._setState(nextState, resolvedN)\n\n//   return this._notify({ nextHistory, commit }, notify)\n// }\n\n\nexports.default = History;\n\n//////////////////\n// WEBPACK FOOTER\n// /Users/jamesgillmore/React/redux-first-router/src/history/History.js\n// module id = 99\n// module chunks = 3\n\n//# sourceURL=webpack:////Users/jamesgillmore/React/redux-first-router/src/history/History.js?"
    )

    /***/
  }
})
